<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>自定义滚动条</title>
  <link rel="stylesheet" href="resource/reset.css">
  <style>
    body {
      background-color: #eee;
    }
    .scroll_demo {
      width: 540px;
      background: #fff;
      border: 1px solid #e5e5e5;
      margin: 30px auto;
    }
    .scroll_tab {
      height: 34px;
      margin: 0;
      padding: 0;
      list-style: none;
      border-bottom: 1px solid #e5e5e5;
      color: #666;
      background: #f8f8f8;
    }
    .scroll_tab > .tab_item {
      float: left;
      font: 16px/34px "Microsoft Yahei";
      border-right: 1px solid #e5e5e5;
      padding: 0 20px;
      cursor: pointer;
    }
    .scroll_tab > .tab_active {
      border-top: 2px solid #00be3c;
      color: #00be3c;
      background: #fff;
      margin-top: -1px;
      margin-bottom: -1px;
    }
    .scroll_wrap {
      position: relative;
      height: 300px;
    } 
    .scroll_wrap .scroll_cont {
      height: 100%;
      padding: 0 15px;
      overflow: hidden;
    }
    .scroll_wrap .scroll_cont h3 {
      font: 16px/3 "Microsoft Yahei";
      text-align: center;
      margin: 10px 0 0;
    }
    .scroll_wrap .scroll_cont p {
      font-size: 14px;
      line-height: 30px;
      text-indent: 2em;
      margin: 0 0 10px; 
    }
    /*滚动条*/
    .scroll_wrap .scroll_bar {
      position: absolute;
      top: 0;
      right: 0;
      width: 10px;
      height: 100%;
      background-color: #eaeaea;
    }
    .scroll_wrap .scroll_bar .scroll_slider {
      position: absolute;
      top: 0;
      left: 1px;
      width: 8px;
      height: 30px;
      background-color: #fff;
    }
  </style>
</head>
<body>
  <div class="scroll_demo">
    <!-- 标签切换区 -->
    <ul class="scroll_tab">
      <li class="tab_item tab_active">第一篇</li>
      <li class="tab_item">第二篇</li>
      <li class="tab_item">第三篇</li>
      <li class="tab_item">第四篇</li>
    </ul>
    <!-- 滚动内容区 -->
    <div class="scroll_wrap">
      <!-- 滚动内容 -->
      <div class="scroll_cont">
        <h3 class="anchor">机器人公司Geek+完成6000万美元B轮投资 华平投资领投</h3>
        <div class="scroll_ol">
          <p>
            Geek+于2015年初成立，以AI和机器人为核心，为客户提供全面一站式的智能物流解决方案。Geek+将人工智能作为大脑进行自主决策，通过机器人为肢体完成自动操作，其系统产品和解决方案覆盖货品存储、订单拣选、自动搬运、包裹分拣等应用场景。Geek+采用高度智能化的技术，实现订单动态拆分和整合、智能补货退货、SKU关联度分析，机器人路径优化、自主避撞和拥堵控制、货架热度预测和布局动态优化等功能。
          </p>
          <p>
            作为全球物流机器人领域的领先公司，Geek+在技术实力、产品性能和市场份额上与业内其他公司相比具有较大的优势。截至目前，Geek+已为包括天猫、唯品会、苏宁在内的20多个客户的仓库部署了近1000台机器人。Geek+不仅是中国规模最大的物流机器人公司，同时也运营着国内单仓体量最大、智能机器人数量最多、出货能力最强的智能机器人仓库，并帮助多个大型电商客户顺利度过618、双11等多个节日大促的考验。Geek+预计到2017年底部署的机器人数量将达到2000台。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
        </div>
        <h3 class="anchor">机器人公司 华平投资领投</h3>
        <div class="scroll_ol">
          <p>
            Geek+于2015年初成立，以AI和机器人为核心，为客户提供全面一站式的智能物流解决方案。Geek+将人工智能作为大脑进行自主决策，通过机器人为肢体完成自动操作，其系统产品和解决方案覆盖货品存储、订单拣选、自动搬运、包裹分拣等应用场景。Geek+采用高度智能化的技术，实现订单动态拆分和整合、智能补货退货、SKU关联度分析，机器人路径优化、自主避撞和拥堵控制、货架热度预测和布局动态优化等功能。
          </p>
          <p>
            作为全球物流机器人领域的领先公司，Geek+在技术实力、产品性能和市场份额上与业内其他公司相比具有较大的优势。截至目前，Geek+已为包括天猫、唯品会、苏宁在内的20多个客户的仓库部署了近1000台机器人。Geek+不仅是中国规模最大的物流机器人公司，同时也运营着国内单仓体量最大、智能机器人数量最多、出货能力最强的智能机器人仓库，并帮助多个大型电商客户顺利度过618、双11等多个节日大促的考验。Geek+预计到2017年底部署的机器人数量将达到2000台。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
        </div>
        <h3 class="anchor">机器人公司Geek+完成B轮投资 华平投资领投</h3>
        <div class="scroll_ol">
          <p>
            Geek+于2015年初成立，以AI和机器人为核心，为客户提供全面一站式的智能物流解决方案。Geek+将人工智能作为大脑进行自主决策，通过机器人为肢体完成自动操作，其系统产品和解决方案覆盖货品存储、订单拣选、自动搬运、包裹分拣等应用场景。Geek+采用高度智能化的技术，实现订单动态拆分和整合、智能补货退货、SKU关联度分析，机器人路径优化、自主避撞和拥堵控制、货架热度预测和布局动态优化等功能。
          </p>
          <p>
            作为全球物流机器人领域的领先公司，Geek+在技术实力、产品性能和市场份额上与业内其他公司相比具有较大的优势。截至目前，Geek+已为包括天猫、唯品会、苏宁在内的20多个客户的仓库部署了近1000台机器人。Geek+不仅是中国规模最大的物流机器人公司，同时也运营着国内单仓体量最大、智能机器人数量最多、出货能力最强的智能机器人仓库，并帮助多个大型电商客户顺利度过618、双11等多个节日大促的考验。Geek+预计到2017年底部署的机器人数量将达到2000台。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
          <p>
            本轮融资完成后，Geek+的投资方阵容仍为纯财务投资人。这样的资本背景将有助于Geek+继续保持第三方服务提供商的定位，面向整个市场提供稳定、专业、高品质的服务，而避免出现业内某些公司被电商巨头收购后不再为原有客户服务的类似问题发生。
          </p>
        </div>
        <h3 class="anchor">机器人公司Geek+完成6000万美元</h3>
        <div class="scroll_ol">
          <p>
            Geek+于2015年初成立，以AI和机器人为核心，为客户提供全面一站式的智能物流解决方案。Geek+将人工智能作为大脑进行自主决策，通过机器人为肢体完成自动操作，其系统产品和解决方案覆盖货品存储、订单拣选、自动搬运、包裹分拣等应用场景。Geek+采用高度智能化的技术，实现订单动态拆分和整合、智能补货退货、SKU关联度分析，机器人路径优化、自主避撞和拥堵控制、货架热度预测和布局动态优化等功能。
          </p>
        </div>
        <div class="correct_bot"></div>
      </div>
      <!-- 滚动条 -->
      <div class="scroll_bar">
        <div class="scroll_slider"></div>
      </div>
    </div>
  </div>
  <script src="../js/jquery-3.2.1.min.js"></script>
  <script>
    var Scroll = {};
    (function(win,doc,$) {
      function CusScrollBar(options) {
        this._init(options);
      }    
      $.extend(CusScrollBar.prototype, {
        _init: function(options) {
          var self = this;
          self.options = {
            scrollDir: 'y', // 滚动的方向
            conSelector: '', // 滚动内容的选择器
            barSelector: '', // 滚动条选择器
            sliderSelector: '', // 滚动滑块选择器
            tabItemSelector: '.tab_item',
            tabActiveClass: 'tab_active',
            anchorSelector: '.anchor',
            wheelStep: 10,
            correctSelector: '.correct_bot', //矫正元素
            articleSelector: '.scroll_ol' //文章选择器
          };
          $.extend(true, self.options, options || {});
          self._initDomEvent();
          return self;
        },
        //初始化dom引用
        _initDomEvent: function() {
          var opts = this.options;
          //滚动内容区对象
          this.$cont = $(opts.conSelector);
          this.$slider = $(opts.sliderSelector);
          this.$bar = opts.barSelector ? $(opts.barSelector) : self.$slider.parent();
          //标签页
          this.$tabItem = $(opts.tabItemSelector);
          this.$anchor = $(opts.anchorSelector);
          this.$correct = $(opts.correctSelector);
          this.$article = $(opts.articleSelector)
          this.$doc = $(doc);
          this._initSliderDragEvent()._bindContScroll()._bindMousewheel()._initTabEvent()._initArticleHeight();
        },
        //初始化文档高度
        _initArticleHeight: function() {
          var self = this,
              lastArticle = self.$article.last();

          var lastArticleHeight = lastArticle.height(),
              contheight = self.$cont.height();

          if (lastArticleHeight < contheight) {
            self.$correct[0].style.height = contheight - lastArticleHeight -self.$anchor.outerHeight() + 'px';
          }
          return self;
        },
        //初始化滑块拖动功能
        _initSliderDragEvent : function() {
          var self = this;
          var slider = this.$slider,
              sliderEl = slider[0];
          if (sliderEl) {
            var doc = this.$doc,
                dragStartPagePosition,
                dragStartScrollPosition,
                dragContBarRate;
            function mousemoveHandler(e) {
              e.preventDefault();
              if (dragStartPagePosition === null) {
                return;
              }
              self.scrollTo(dragStartPagePosition + (e.pageY - dragStartPagePosition) * dragContBarRate);
            }

            slider.on('mousedown', function(e) {
              e.preventDefault();
              dragStartPagePosition = e.pageY;
              dragStartScrollPosition = self.$cont[0].scrollTop;
              dragContBarRate = self.getMaxScrollPosition()/self.getMaxSliderPosition();
              doc.on('mousemove.scroll', mousemoveHandler).on('mouseup.scroll',function(e) {
                console.log('mouseup');
                //解除事件绑定
                doc.off('.scroll');
              })
            })
          }
          return self;
        },

        //初始化标签切换功能
        _initTabEvent: function() {
          var self = this;
          self.$tabItem.on('click', function(e){
            e.preventDefault();
            var index = $(this).index();
            self.changeTabSelect(index);
            //根据点击的tab滚动到锚地指定的距离
            self.scrollTo(self.$cont[0].scrollTop + self.getAnchorPosition(index))
          });
          return self;
        },

        //监听内容的滚动,同步滑块的位置
        _bindContScroll: function() {
          var self = this;
          self.$cont.on('scroll',function() {
            var sliderEl = self.$slider && self.$slider[0];
            if (sliderEl) {
              sliderEl.style.top = self.getSliderPositon() + 'px';
            }
          });
          return self;
        },
        _bindMousewheel: function() {
          var self = this;
          self.$cont.on('mousewheel DOMMouseScroll', function(e) {
            e.preventDefault();
            var oEv = e.originalEvent,
                wheelRange = oEv.wheelDelta ? -oEv.wheelDelta/120 : (oEv.detail || 0)/3;

            self.scrollTo(self.$cont[0].scrollTop + wheelRange * self.options.wheelStep);
          });
          return self;
        },
        //切换选中的标签
        changeTabSelect: function(index) {
          var self = this;
          var active = self.options.tabActiveClass;
          return self.$tabItem.eq(index).addClass(active).siblings().removeClass(active);
        }, 
        //获取指定锚点到上边界的像素数
        getAnchorPosition: function(index) {
          return this.$anchor.eq(index).position().top;
        },
        //获取每个锚点位置信息的数组
        getAllAnchorPosition: function() {
          var self = this,
              allPositionArr = [];
          for (var i = 0; i < self.$anchor.length; i++) {
            allPositionArr.push(self.$cont[0].scrollTop + self.getAnchorPosition(i));
          }
          return allPositionArr;
        },
        //计算滑块的当前的位置       
        getSliderPositon: function() {
          var self = this,
              maxSliderPosition = self.getMaxSliderPosition();

          return Math.min(maxSliderPosition, maxSliderPosition * self.$cont[0].scrollTop/self.getMaxScrollPosition());

        },
        //内容可移动的距离
        getMaxScrollPosition: function() {
          var self = this;
          return Math.max(self.$cont.height(),self.$cont[0].scrollHeight - self.$cont.height());
        },
        //滑块可移动的距离
        getMaxSliderPosition: function() {
          var self = this;
          return self.$bar.height() - self.$slider.height();
        },
        scrollTo: function(positionVal) {
          var self = this;
          var posArr = self.getAllAnchorPosition();
          //滚动条的位置与tab标签的对应
          function getIndex(positionVal) {
            for(var i = posArr.length - 1; i >= 0; i--) {
              if (positionVal >= posArr[i]) {
                return i;
              }else{
                continue;
              }
            };
          }
          //锚点数与标签数相同
          if (posArr.length === self.$tabItem.length) {
            self.changeTabSelect(getIndex(positionVal));
          }
          self.$cont.scrollTop(positionVal);
        }
      });
      Scroll.CusScrollBar = CusScrollBar; 
    })(window,document,jQuery);
    var scroll = new Scroll.CusScrollBar({
      conSelector: '.scroll_cont',
      barSelector: '.scroll_bar',
      sliderSelector: '.scroll_slider'
    });
  </script>
</body>
</html>